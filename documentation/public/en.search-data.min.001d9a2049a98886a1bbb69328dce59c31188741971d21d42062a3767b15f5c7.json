[{"id":0,"href":"/docs/guides/how-to-run/","title":"How to Run","section":"Guides","content":" Carbonaut: How To Run # The current Carbonaut version is a POC (Proof of Concept). The project is not tested for large environments. There are already several security and quality checks, but no security assessment has been done and there is a risk of vulnerabilities if it is deployed. The system is not hardened. Carbonaut can be run as binary or container. The latest releases can be found here.\n"},{"id":1,"href":"/docs/reference/server-api/","title":"Server API","section":"Reference","content":" Carbonaut Server API # The Carbonaut Server is a lightweight HTTP server designed to provide metrics and static data management using a caching mechanism to optimize data delivery. This server is built using Go and utilizes a custom connector for data retrieval and a cache for data storage.\nConfiguration # Struct: Config # Port (int): The network port on which the server listens. Default is 8088. The port can be specified in the config.yaml. HTTP Endpoints # / Method: GET Description: Returns a message indicating that the Carbonaut Server is running and displays the metrics collection endpoint. /static-data Method: GET Description: Provides static data retrieved via the connector. If available, data is served from the cache; otherwise, it is retrieved from the state and cached. /metrics-json Method: GET Description: Returns collected data metrics. If available, data is served from the cache; otherwise, it is freshly collected, serialized to JSON, and cached. /stop Method: GET Description: Stops the server. It sends a signal through the ExitChan to shut down the server. Caching Strategy # The server employs a simple caching mechanism with a fixed expiration time for entries. It purges expired items every 5 minutes and caches both metrics data and static data for quick access.\n"},{"id":2,"href":"/docs/concepts/components/","title":"Components","section":"Concepts","content":" Carbonaut Components # Carbonaut\u0026rsquo;s internal components are explained in this document. At a high level, Carbonaut serves metrics and integration functionallity over a server component which calls endpoints in the connector to collect metrics. The connector is the central component which controls the main application life cycle, it inhales the logic registering plugins and managing state. Plugins implement providers which deliver different kinds of data which is required to get the holistic overview of cloud native environmental sustainability.\nThe next sections will focus on each building block as well as the data schema.\nServer # The Carbonaut Server hosts an HTTP server which serves collected metrics and serves an access point to configure the deployment at runtime. Detailed information can be found in the api documentation. As of now the server exposes metrics in json format. These metrics could be mapped to prometheus metric types down the road for better integration in the cloud native ecosystem.\nConnector # At a higher level, Carbonaut integrates data over providers, and exposes collected data over a server (see Server API docs). Between these two components is the Connector component which contains the main lifecycle of the system.\nInternal Runtime # The connector, parses the configuration, starts and stopps plugins, updates the local state which contains the topology of the IT infrastructure and collects data from all connected providers which the API server exposes in different formats. A simplified version of the runtime is visualized below.\nsequenceDiagram autonumber actor A as Alice the Platform Engineer actor J as John the DevOps Engineer participant CMain as Carbonaut CMD participant CServer as Carbonaut Server participant CConn as Carbonaut Connector participant EInfra as Infrastructure Data Sources participant EEnv as Environment Data Sources A-\u0026gt;\u0026gt;CMain: Start Carbonaut activate CMain CMain-\u0026gt;\u0026gt;CConn: Run (main lifecycle) activate CConn CMain-\u0026gt;\u0026gt;CServer: Start Listening activate CServer A--\u0026gt;\u0026gt;CServer: Update Configuration file Note over CConn,EInfra: Carbonaut syncronizes the static resource state of \u0026lt;br\u0026gt; the infrastructure and maintains a mirrored state note right of CConn: Look up configuration file note right of CConn: Update State with Accounts par [Mirror Static Resource \u0026amp; Environment Data] loop activate CConn note right of CConn: Parse configured \u0026#39;Accounts\u0026#39; \u0026lt;br\u0026gt; (new, old and remaining) CConn-\u0026gt;\u0026gt;EInfra: Discover \u0026#39;Projects\u0026#39; \u0026lt;br\u0026gt; (new, old and remaining) note right of CConn: Update State with Projects loop CConn-\u0026gt;\u0026gt;EInfra: Discover \u0026#39;Resources\u0026#39; by \u0026#39;Project\u0026#39; \u0026lt;br\u0026gt; (new, old and remaining) note right of CConn: Update State with Resources end deactivate CConn end and [Serve Static \u0026amp; Dynamic Data] J-\u0026gt;\u0026gt;CServer: I would like to get Carbonaut\u0026#39;s metrics activate J activate CServer note right of CServer: Serve from Cache if set CServer-\u0026gt;\u0026gt;CConn: Collect Static and Dynamic Data activate CConn loop Over all Accounts loop Over all Projects loop Over all Resources CConn-\u0026gt;\u0026gt;EInfra: Collect Dynamic Data \u0026lt;br\u0026gt; of the resource (dynres) activate EInfra EInfra--\u0026gt;\u0026gt;CConn: Energy Usage and CPU Frequency data deactivate EInfra CConn-\u0026gt;\u0026gt;EEnv: Collect Dynamic Data (dynenv) activate EEnv EEnv--\u0026gt;\u0026gt;CConn: Energy Mix data deactivate EEnv end end end note right of CConn: Collected dynamic data for each resource note right of CConn: Use static data from state CConn--\u0026gt;\u0026gt;CServer: Return Dynamic and Static Data deactivate CConn CServer--\u0026gt;\u0026gt;J: Visualize state data deactivate J note right of CServer: Update Cache deactivate CServer end deactivate CConn deactivate CServer CMain--\u0026gt;\u0026gt;A: Carbonaut Stopped deactivate CMain Provider \u0026amp; Plugins # Carbonaut collects data of your infrastructure over data providers. Providers are interfaces which are implemented as plugins (see Plugin section in the sidebar). There are three different kinds of providers:\nDynamic Environment Provider collects data about the Energy Mix (may be extended). Dynamic Resource Provider collects data about Energy Usage, CPU Frequency etc. (may be extended). Static Resource Provider collects data about CPU, Memory, IP etc. and also data about the geolocation and region of the IT resource. These providers depend on each other. To collect energy usage of a system you first need to be aware of the system\u0026rsquo;s topology. In the cloud environment we have heterogenous systems which changes dynamically. Therefore Resources are captured in projects (like K8s namespace\u0026rsquo;s) and accounts (like K8s cluster\u0026rsquo;s). The static resource provider just references the account and further discovery of projects and resources are done at runtime.\nProviders expose interfaces which are defined in the schema reference document. The dynenv provider integrates data about the energy mix. The dynres provider integrates data umong other things about energy usage. The staticres provider integrates data umong other things about Operating System, Memory, Region.\n"},{"id":3,"href":"/docs/guides/how-to-setup-dev-environment/","title":"How to Setup Dev Environment","section":"Guides","content":" Carbonaut: How To Setup Your Dev Environment # This guide gives information how to start setup your development environment so you are ready to customize the current Carbonaut version.\nThere are two options which you can use. Either you use a vscode dev container which uses Docker in the background as virtualized dev environment. Or you use your regular machine for development. If you are on Windows you need to work with WSL (Linux Subsystem for Windows) and note that there may be some issues since Carbonaut was developed on macOS and not tested on other platforms. If any step is not working, please open a PR to improve this document.\nMake sure to work on a fork and not the cloned carbonaut repository! See contributor guide for more information.\n1. Manual Setup # If you are on Windows install WSL and work going forward on the Linux subsystem. Install Go and NPM. Go is used to compile the project and install additional tooling like golangci-lint. NPM is used to install additional tooling like pre-commit and prettier for formatting. All installs are listed in the Makefile under installs Current Go version used on macOS go version go1.22.2 darwin/arm64 Current NPM version used on macOS 10.8.0 Install dependencies with make install. 2. Use VSCode Dev Containers # Dev Containers are not yet implemented. "},{"id":4,"href":"/docs/reference/schema/","title":"Schema","section":"Reference","content":" provider # import \u0026#34;carbonaut.dev/pkg/provider\u0026#34; Index # type Config type Data type EnvConfig type Res type ResConfig type Config # type Config struct { Resources ResConfig `json:\u0026#34;resources\u0026#34; yaml:\u0026#34;resources\u0026#34;` Environment *EnvConfig `json:\u0026#34;environment\u0026#34; yaml:\u0026#34;environment\u0026#34;` } type Data # type Data map[resource.AccountName]resource.AccountData type EnvConfig # type EnvConfig struct { DynamicEnvConfig *dynenv.Config `json:\u0026#34;dynamic_environment\u0026#34; yaml:\u0026#34;dynamic_environment\u0026#34;` } type Res # type Res struct { StaticResConfig *staticres.Config `json:\u0026#34;static_resource\u0026#34; yaml:\u0026#34;static_resource\u0026#34;` DynamicResConfig *dynres.Config `json:\u0026#34;dynamic_resource\u0026#34; yaml:\u0026#34;dynamic_resource\u0026#34;` } type ResConfig # type ResConfig map[resource.AccountName]Res environment # import \u0026#34;carbonaut.dev/pkg/provider/environment\u0026#34; Index # type DynamicEnvData type DynamicEnvData # type DynamicEnvData struct { SolarPercentage float64 `json:\u0026#34;solar_percentage\u0026#34; yaml:\u0026#34;solar_percentage\u0026#34;` WindPercentage float64 `json:\u0026#34;wind_percentage\u0026#34; yaml:\u0026#34;wind_percentage\u0026#34;` HydroPercentage float64 `json:\u0026#34;hydro_percentage\u0026#34; yaml:\u0026#34;hydro_percentage\u0026#34;` NuclearPercentage float64 `json:\u0026#34;nuclear_percentage\u0026#34; yaml:\u0026#34;nuclear_percentage\u0026#34;` GeothermalPercentage float64 `json:\u0026#34;geothermal_percentage\u0026#34; yaml:\u0026#34;geothermal_percentage\u0026#34;` GasPercentage float64 `json:\u0026#34;gas_percentage\u0026#34; yaml:\u0026#34;gas_percentage\u0026#34;` OilPercentage float64 `json:\u0026#34;oil_percentage\u0026#34; yaml:\u0026#34;oil_percentage\u0026#34;` BiomassPercentage float64 `json:\u0026#34;biomass_percentage\u0026#34; yaml:\u0026#34;biomass_percentage\u0026#34;` CoalPercentage float64 `json:\u0026#34;coal_percentage\u0026#34; yaml:\u0026#34;coal_percentage\u0026#34;` OtherSourcesPercentage float64 `json:\u0026#34;other_sources_percentage\u0026#34; yaml:\u0026#34;other_sources_percentage\u0026#34;` FossilFuelsPercentage float64 `json:\u0026#34;fossil_fuels_percentage\u0026#34; yaml:\u0026#34;fossil_fuels_percentage\u0026#34;` RenewablePercentage float64 `json:\u0026#34;renewable_percentage\u0026#34; yaml:\u0026#34;renewable_percentage\u0026#34;` } plugin # import \u0026#34;carbonaut.dev/pkg/provider/plugin\u0026#34; Index # type Kind type Kind # type Kind string resource # import \u0026#34;carbonaut.dev/pkg/provider/resource\u0026#34; Index # type AccountData type AccountName type CPU type DRIVE type DynamicData type DynamicResData type GPU type Location type NIC type OS type ProjectData type ProjectName type ResourceData type ResourceName type StaticData type StaticResData type AccountData # type AccountData map[ProjectName]ProjectData type AccountName # type AccountName string type CPU # type CPU struct { Count int `json:\u0026#34;count\u0026#34; yaml:\u0026#34;count\u0026#34; default:\u0026#34;1\u0026#34;` Type string `json:\u0026#34;type\u0026#34; yaml:\u0026#34;type\u0026#34; default:\u0026#34;Intel Xeon E-2278G 8-Core Processor @ 3.40GHz\u0026#34;` Cores string `json:\u0026#34;cores\u0026#34; yaml:\u0026#34;cores\u0026#34; default:\u0026#34;8\u0026#34;` Threads string `json:\u0026#34;threads\u0026#34; yaml:\u0026#34;threads\u0026#34; default:\u0026#34;16\u0026#34;` Speed string `json:\u0026#34;speed\u0026#34; yaml:\u0026#34;speed\u0026#34; default:\u0026#34;3.40GHz\u0026#34;` Arch string `json:\u0026#34;arch\u0026#34; yaml:\u0026#34;arch\u0026#34; default:\u0026#34;x86\u0026#34;` Model string `json:\u0026#34;model\u0026#34; yaml:\u0026#34;model\u0026#34; default:\u0026#34;E-2278G\u0026#34;` Manufacturer string `json:\u0026#34;manufacturer\u0026#34; yaml:\u0026#34;manufacturer\u0026#34; default:\u0026#34;Intel\u0026#34;` Name string `json:\u0026#34;name\u0026#34; yaml:\u0026#34;name\u0026#34; default:\u0026#34;Intel Xeon E-2278G Processor\u0026#34;` } type DRIVE # type DRIVE struct { Count int `json:\u0026#34;count\u0026#34; yaml:\u0026#34;count\u0026#34; default:\u0026#34;2\u0026#34;` Type string `json:\u0026#34;type\u0026#34; yaml:\u0026#34;type\u0026#34; default:\u0026#34;SSD\u0026#34;` Size string `json:\u0026#34;size\u0026#34; yaml:\u0026#34;type\u0026#34; default:\u0026#34;480GB\u0026#34;` } type DynamicData # type DynamicData struct { ResData *DynamicResData `json:\u0026#34;res_data\u0026#34; yaml:\u0026#34;res_data\u0026#34;` EnvData *environment.DynamicEnvData `json:\u0026#34;env_data\u0026#34; yaml:\u0026#34;env_data\u0026#34;` } type DynamicResData # energy and utilization data\ntype DynamicResData struct { CPUFrequency float64 `json:\u0026#34;cpu_frequency\u0026#34; yaml:\u0026#34;cpu_frequency\u0026#34;` EnergyHostMicrojoules int `json:\u0026#34;energy_host_mirojoules\u0026#34; yaml:\u0026#34;energy_host_mirojoules\u0026#34;` CPULoadPercentage float64 `json:\u0026#34;cpu_load_percentage\u0026#34; yaml:\u0026#34;cpu_load_percentage\u0026#34;` } type GPU # type GPU struct { Count int `json:\u0026#34;count\u0026#34; yaml:\u0026#34;count\u0026#34; default:\u0026#34;1\u0026#34;` Type string `json:\u0026#34;type\u0026#34; yaml:\u0026#34;type\u0026#34; default:\u0026#34;Intel HD Graphics P630\u0026#34;` } type Location # type Location struct { City string `json:\u0026#34;city\u0026#34; yaml:\u0026#34;city\u0026#34; default:\u0026#34;Frankfurt\u0026#34;` Country string `json:\u0026#34;country\u0026#34; yaml:\u0026#34;country\u0026#34; default:\u0026#34;DE\u0026#34;` Address string `json:\u0026#34;address\u0026#34; yaml:\u0026#34;address\u0026#34; default:\u0026#34;Kruppstrasse 121-127\u0026#34;` ZipCode string `json:\u0026#34;zip_code\u0026#34; yaml:\u0026#34;zip_code\u0026#34; default:\u0026#34;60388\u0026#34;` Code string `json:\u0026#34;code\u0026#34; yaml:\u0026#34;code\u0026#34; default:\u0026#34;fr\u0026#34;` } type NIC # type NIC struct { Count int `json:\u0026#34;count\u0026#34; yaml:\u0026#34;count\u0026#34; default:\u0026#34;1\u0026#34;` Type string `json:\u0026#34;type\u0026#34; yaml:\u0026#34;type\u0026#34; default:\u0026#34;10Gbps\u0026#34;` } type OS # type OS struct { Version string `json:\u0026#34;version\u0026#34; yaml:\u0026#34;version\u0026#34; default:\u0026#34;12\u0026#34;` Distro string `json:\u0026#34;distro\u0026#34; yaml:\u0026#34;distro\u0026#34; default:\u0026#34;debian\u0026#34;` Name string `json:\u0026#34;name\u0026#34; yaml:\u0026#34;name\u0026#34; default:\u0026#34;Debian 12\u0026#34;` } type ProjectData # type ProjectData map[ResourceName]*ResourceData type ProjectName # type ProjectName string type ResourceData # type ResourceData struct { DynamicData *DynamicData `json:\u0026#34;dynamic_data\u0026#34; yaml:\u0026#34;dynamic_data\u0026#34;` StaticData *StaticResData `json:\u0026#34;static_data\u0026#34; yaml:\u0026#34;static_data\u0026#34;` } type ResourceName # type ResourceName string type StaticData # type StaticData struct { ResData *StaticResData `json:\u0026#34;res_data\u0026#34; yaml:\u0026#34;res_data\u0026#34;` } type StaticResData # Data represents computer hardware data.\ntype StaticResData struct { ID string `json:\u0026#34;id\u0026#34; yaml:\u0026#34;id\u0026#34; default:\u0026#34;0131acc3-82d8-488b-a8e2-c4a00e897145\u0026#34;` User string `json:\u0026#34;user\u0026#34; yaml:\u0026#34;user\u0026#34; default:\u0026#34;root\u0026#34;` OS *OS `json:\u0026#34;os\u0026#34; yaml:\u0026#34;os\u0026#34;` IPv4 string `json:\u0026#34;ipv4\u0026#34; yaml:\u0026#34;ipv4\u0026#34; default:\u0026#34;145.40.93.80\u0026#34;` CPUs []*CPU `json:\u0026#34;cpus\u0026#34; yaml:\u0026#34;cpus\u0026#34;` GPUs []*GPU `json:\u0026#34;gpus\u0026#34; yaml:\u0026#34;gpus\u0026#34;` NICs []*NIC `json:\u0026#34;nics\u0026#34; yaml:\u0026#34;nics\u0026#34;` Drives []*DRIVE `json:\u0026#34;drives\u0026#34; yaml:\u0026#34;drives\u0026#34;` MemoryGB string `json:\u0026#34;memory_gb\u0026#34; yaml:\u0026#34;memory_gb\u0026#34; default:\u0026#34;32GB\u0026#34;` Location *Location `json:\u0026#34;location\u0026#34; yaml:\u0026#34;location\u0026#34;` } topology # import \u0026#34;carbonaut.dev/pkg/provider/topology\u0026#34; Index # Variables type AccountID type AccountT type ProjectID type ProjectT type Projects type ResourceID type ResourceT type Resources type T Variables # var ( AccountNotFoundID AccountID = -1 ProjectNotFoundID ProjectID = -1 ResourceNotFoundID ResourceID = -1 ) type AccountID # type AccountID int32 type AccountT # type AccountT struct { Name *resource.AccountName `json:\u0026#34;name\u0026#34;` Projects Projects `json:\u0026#34;projects\u0026#34;` CreatedAt time.Time `json:\u0026#34;created_at\u0026#34;` ProjectIDCounter *int32 `json:\u0026#34;-\u0026#34;` Config *staticres.Config `json:\u0026#34;-\u0026#34;` } type ProjectID # type ProjectID int32 type ProjectT # type ProjectT struct { Name *resource.ProjectName `json:\u0026#34;name\u0026#34;` Resources Resources `json:\u0026#34;resources\u0026#34;` CreatedAt time.Time `json:\u0026#34;created_at\u0026#34;` ResourceIDCounter *int32 `json:\u0026#34;-\u0026#34;` } type Projects # type Projects map[ProjectID]*ProjectT type ResourceID # type ResourceID int32 type ResourceT # internal state\ntype ResourceT struct { Name *resource.ResourceName `json:\u0026#34;name\u0026#34;` StaticData *resource.StaticResData `json:\u0026#34;static_data\u0026#34;` CreatedAt time.Time `json:\u0026#34;created_at\u0026#34;` Plugin *plugin.Kind `json:\u0026#34;plugin\u0026#34;` } type Resources # type Resources map[ResourceID]*ResourceT type T # type T struct { Accounts map[AccountID]*AccountT `json:\u0026#34;accounts\u0026#34; yaml:\u0026#34;accounts\u0026#34;` AccountsIDCounter *int32 `json:\u0026#34;-\u0026#34;` } dynenv # import \u0026#34;carbonaut.dev/pkg/provider/types/dynenv\u0026#34; Index # type Config type Provider type Config # type Config struct { Plugin *plugin.Kind `json:\u0026#34;plugin\u0026#34; yaml:\u0026#34;plugin\u0026#34;` AccessKeyEnv *string `json:\u0026#34;access_key_env\u0026#34; yaml:\u0026#34;access_key_env\u0026#34;` } type Provider # type Provider interface { GetName() *plugin.Kind GetDynamicEnvironmentData(*resource.Location) (*environment.DynamicEnvData, error) } dynres # import \u0026#34;carbonaut.dev/pkg/provider/types/dynres\u0026#34; Index # type Config type Provider type Config # type Config struct { Plugin plugin.Kind `json:\u0026#34;plugin\u0026#34; yaml:\u0026#34;plugin\u0026#34;` // Endpoint that is accessed to collec the data. // The IPv4 address will be collected from the static data thats looked up. Endpoint string `json:\u0026#34;endpoint\u0026#34; yaml:\u0026#34;endpoint\u0026#34;` // Client certificate file Cert string `json:\u0026#34;cert\u0026#34; yaml:\u0026#34;cert\u0026#34;` // Client certificate\u0026#39;s key file Key string `json:\u0026#34;key\u0026#34; yaml:\u0026#34;key\u0026#34;` // Accept any certificate during TLS handshake. Insecure, use only for testing AcceptInvalidCert bool `json:\u0026#34;accept_invalid_cert\u0026#34; yaml:\u0026#34;accept_invalid_cert\u0026#34;` } type Provider # type Provider interface { GetName() *plugin.Kind GetDynamicResourceData(*resource.StaticResData) (*resource.DynamicResData, error) } staticres # import \u0026#34;carbonaut.dev/pkg/provider/types/staticres\u0026#34; Index # type Config type Provider type Config # type Config struct { Plugin *plugin.Kind `json:\u0026#34;plugin\u0026#34; yaml:\u0026#34;plugin\u0026#34;` AccessKeyEnv *string `json:\u0026#34;access_key_env\u0026#34; yaml:\u0026#34;access_key_env\u0026#34;` } type Provider # type Provider interface { GetName() *plugin.Kind GetStaticResourceData(*resource.ProjectName, *resource.ResourceName) (*resource.StaticResData, error) DiscoverStaticResourceIdentifiers(*resource.ProjectName) ([]*resource.ResourceName, error) DiscoverProjectIdentifiers() ([]*resource.ProjectName, error) } Generated by gomarkdoc\n"},{"id":5,"href":"/docs/guides/how-to-develop-internals/","title":"How to Develop Internals","section":"Guides","content":" Carbonaut: How To Develop Internals # This guide gives information how to start develop internals of Carbonaut. Carbonauts source code is developed in Go and located in the pkg/ directory of the project. After this guide you are able to make changes, verify if made changes work and how to push these changes and get towards merging it to the main Carbonaut project.\nSetup:\nRead the contributors guide here and fork the carbonaut repository. Setup your dev environment. Follow this guide. Test building the project locally make build Run Carbonaut in test-run mode ./main --test-run. Carbonaut will load a test config and shut down after a couple of seconds automatically. Make changes to the codebase\nVerify changes made:\nRun make verify. INFO: Some steps run commands like go mod tidy which may change go.mod (depending on your edits) if go.mod was changed during make verify, the check will fail but its safe to rerun it. Optionally you can run e2e checks see this guide "},{"id":6,"href":"/docs/guides/how-to-develop-plugins/","title":"How to Develop Plugins","section":"Guides","content":" Carbonaut: How To Develop Plugins # Setup:\nSetup your dev environment. Follow this guide. Read up the concepts documentation about provider and plugins. Identify which provider interface you need to implement:\nChoose the provider which is used to implement the data you like to integrate. dynres implements energy usage, cpu frequency etc. staticres implements cloud provider, hypervisors etc. that manage your infrastructure resources. dynenv implements energy grid APIs Setup your starting point (one of these) dynres: Copy the folder pkg/plugin/dynresplugins/mockenergy and rename it to your plugins name staticres: Copy the folder pkg/plugin/staticresplugins/mockcloudplugin and rename it to your plugins name dynenv: Copy the folder pkg/plugin/dynenvplugins/mockenergymix and rename it to your plugins name Implement the provider. Add unit, integration and optional end to end testing. Make sure to add the provider reference to the plugin file: For dynres add it to pkg/plugin/dynresplugins/dynresplugins.go For staticres add it to pkg/plugin/staticresplugins/staticresplugins.go For dynenv add it to pkg/plugin/dynenvplugins/dynenvplugins.go If applicable add caching. type p struct { // ... cache *cache.Cache } func New(cfg *Config) (p, error) { // Create a cache with an expiration time of 60 seconds, and which // purges expired items every 5 minutes c := cache.New(60*time.Second, 5*time.Minute) // ... } func reqData(id string) (*Data, error) { // ... if cachedData, found := p.cache.Get(id); found { return cachedData, nil } // ... if err := p.cache.Add(id, data, cache.DefaultExpiration); err != nil { return nil, errors.New(\u0026#34;unable to add data to internal cache\u0026#34;) } // ... } Push changes and open a PR to propose merging changes to Carbonaut. See contribution guide. "},{"id":7,"href":"/docs/reference/contributing/","title":"Contributing","section":"Reference","content":" Carbonaut Contributing # The Carbonaut project is a POC project and therefore no community structures are in place. If you find this project interesting enough to contribute, please open up an issue on the repository or directly a PR to discuss your idea. Any contributions are very welcome!\nDevelopment Workflow # Fork the repository and work on your fork. It\u0026rsquo;s recommended to create a feature branch on your fork and open pull requests from feature branches to Carbonaut\u0026rsquo;s main branch. If you have questions about forks, branches etc. take a look at GitHub\u0026rsquo;s documentation. If you forked the repository, install all dependencies, Go, pre-commit and then run make install to install other go nbased tools (see Makefile). If you intend to make changes to the manual testing scenario, refer to this guide. After that you can run make verify to check if everything is setup for local development. Ways of communication # GitHub issues and pull requests on the Carbonaut repository (no forks!) Additional Comments by area of contribution # Improve internal code: improvments are welcome! There are several TODO: XYZ annotations in the code that highlight some areas of improvements. Increasing test coverage and quality: improvements are welcome! The test coverage is not great. Test coverage is uploaded as artifact with each push to the main branch (see actions). You can also run test coverage of the Go code by executing make test-coverage. Adding Provider Plugins: make sure to test it both mocked and as E2E test. Proposing changing data schema or API: sure, make your case. The datamodels are minimal and not complete, changes are welcome. Improvements to this document are welcome!\n"},{"id":8,"href":"/docs/guides/how-to-test-e2e/","title":"How to Test E2E","section":"Guides","content":" Carbonaut: How To Test End To End # Setup your dev environment. Follow this guide. "},{"id":9,"href":"/docs/reference/development/","title":"Development","section":"Reference","content":" Carbonaut Project Development Guide # Install required tools # Install pre-commit which is used to run code checks Run make install which installs Go packages and sets up pre-commit. $ make help Available commands: all - Build project resources and verify code verify - Run verifications on the project (lint, vet, tests) install - Install project dependencies format - Format Go files upgrade - Upgrade project dependencies compile-grpc - Compile gRPC and protobuf definitions test-coverage - Generate and open test coverage report clean-coverage - Clean test coverage reports tf-init - Initialize OpenTofu configuration ... Testing # If access keys to external sources are not set, tests will either set a mock or skip the test. To run all tests the following information needs to be set as environment variables.\nELECTRICITY_MAP_AUTH_TOKEN needs to be set to run all integration tests for the electricity map provider METAL_AUTH_TOKEN needs to be set to run all integration tests for the equinix provider "},{"id":10,"href":"/docs/concepts/advanced/","title":"Advanced","section":"Concepts","content":" Carbonaut Advanced Topics # This page covers several topics to the carbonaut project which offer greater depth to the project.\nINFO: Internal State # Carbonaut maintains an internal state which includes data which does not change until a resource was destroyed. Information about how much CPU cores or which Chip Architecture is considered static resource information. Information about the geolocation which indicate where the resource is hosted is considered static environment information. The data schema is defined here.\nHOW TO: Add new Plugins # Plugins need to implement a provider interface. There are three providers defined as described in the components documentation here. As of now, the plugins need to be part of Carbonaut and integrated so they can be discovered. Available plugins are located in the pkg/plugin/* folder. If a new plugin should be implemented which integrates another cloud provider like GCP, a new staticres plugin needs to be implemented. The plugin is implemented in pkg/plugin/staticresplugins/gcp and referenced in pkg/plugin/staticresplugins/staticresplugin.go. There are example plugins for each provider type which can be used as a starting point.\nHOW TO: Manually build the project # The project pushes binaries to the GitHub release and Docker containers to Docker hub. If you prefer to build binaries manually, you can follow these instructions. In general the entire build process pushing to GitHub and Docker Hub is public and part of the Carbonaut repository.\nPrerequisits install project dependencies:\nInstall dependencies: Install Go and run make install Build Go Binaries # Build Container Images # Setup Testing Infrastructure # See next section \u0026ldquo;HOW TO: Run the end to end scenario\u0026rdquo;\nHOW TO: Run the end to end scenario # TBD\ndocumentation not yet added "},{"id":11,"href":"/docs/","title":"Docs","section":"Introduction","content":" Carbonaut Docs # Documentation can be navigated by the sidebar.\nGet Home "},{"id":12,"href":"/docs/plugins/dyn-environment/energy-map/","title":"Energy Map","section":"Dynamic Environment","content":" Carbonaut Energy Map Plugin # TBD\ndocumentation not yet added Electricity Map: (you can get a free tier account here)\n"},{"id":13,"href":"/docs/plugins/dyn-resource/scaphandre/","title":"Scaphandre","section":"Dynamic Resource","content":" Carbonaut Scpahandre Plugin # TBD\ndocumentation not yet added Scaphandre\n"},{"id":14,"href":"/docs/plugins/static-resource/equinix/","title":"Equinix","section":"Static Resource","content":" Carbonaut Equinix Plugin # TBD\ndocumentation not yet added Equinix\n"}]