[{"id":0,"href":"/docs/concepts/overview/","title":"Overview","section":"Concepts","content":" Carbonaut Concepts Overview # TBD\ndocumentation not yet added "},{"id":1,"href":"/docs/installation/getting-started/","title":"Getting Started","section":"Installation","content":" Carbonaut Getting Started # TBD\ndocumentation not yet added "},{"id":2,"href":"/docs/reference/server-api/","title":"Server API","section":"Reference","content":" Carbonaut Server API # \u0026hellip;\nTBD\ndocumentation not yet added "},{"id":3,"href":"/docs/concepts/architecture/","title":"Architecture","section":"Concepts","content":" Carbonaut Architecture # To get an overview of the resource consumption of a cloud native system, you need to combine different data sources with each other. Carbonaut should be the platform to facilitate the data integration and transformation. To explore the architecture of the carbonaut system we first start with the data sources.\nData Sources # These data sources can be integrated dynamically (we add a data stream to the system) or static as (we use a configuration file to select a formular).\nDynamic Data Sources:\nEnergy: Energy metrics that gives us information about joules used which can be mapped to KwH. IT Resources: IT Resources that include various hardware information like CPU type, CPU cores, storage, DRAM etc. Geolocation: geolocation (longitude, latitude) based on IP address Energy Mix: current energy mix for the specified geolocation Static Data Sources:\nEmission: formualar to estimate the emissions based on the energy consumption, energy mix and IT resource typ. These data sources depend on each other.\nMarkdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa stateDiagram-v2 State1: The state with a note note right of State1 Important information! You can write notes. end note State1 --\u003e State2 note left of State2 : This is the note to the left. graph TD; GEOLOCATION[Geolocation] --depends on--\u003e IT_RESOURCE[IT Resource]; ENERGY_MIX[Energy Mix] --depends on--\u003e GEOLOCATION; ENERGY[Energy] --depends on--\u003e IT_RESOURCE; EMISSION[Emission] --depends on--\u003e ENERGY; EMISSION --depends on--\u003e ENERGY_MIX; EMISSION --depends on--\u003e IT_RESOURCE; From this diagram its clear that in order to expose data about the emissions of the system, it is required to first collect all the other data sources of the system.\nEach of these types of data\nArchitecture Overview # Version 1.0 April 2024\nThis document describes the architecture of the Carbonaut project. Iterations on the architecture as well as deep dives into certain parts are written up in dedicated files.\n1. Overview # This documentation follows the Google Software Design Document structure.\n1.1. Purpose # Carbonaut is used to collect, integrate, and publish metrics related to the sustainability of cloud native environments. It seamlessly integrates with the observability stack in a cloud native setting.\nEnvironmental considerations and awareness of resource usage are generally emerging fields in economics, compelling us to discover innovative approaches for our products and services. For instance, we are transitioning from fast fashion to sustainable fashion, from coal to renewables, and from gasoline-powered to electric and hydrogen vehicles. This requires building an understanding of the supply chain and taking responsibility for how your products or services are assembled. These sustainable transformations vary in impact and quality but affect everything, including software engineering. Software represents another transformation in our economies, challenging current business models in various aspects. Sustainable software engineering merges these transformations.\nIn the realm of software, we find areas like distributed systems and cloud computing, which are major consumers of energy. It is estimated that the energy consumed by data centers globally emits more greenhouse gases than the aviation industry. Therefore, there is a pressing need to engage in this transformation and shape cloud technology in a more sustainable manner. Fortunately, this field is not confined to private companies but is a significant and industry-relevant area known as cloud native.\n1.2. Scope # This project focuses on the development of a single module that may be extended through plugins. If developed plugins should be integrated directly into the module, resulting in a single binary. There may also be an option to deploy multiple instances of this module to support higher throughput.\nThe primary role of the module is not to collect metrics itself; rather, it integrates with other tools that generate these metrics. However, to enhance the quality of the metrics by combining and refining them, such functionality can be incorporated within the module.\n1.3. Requirements # 1.3.1. Functional Requirements**: # Plugin Integration and Management: The system must support the integration of plugins directly into the main module, creating a unified binary. The module must provide an interface for loading and managing plugins. All plugins will follow a common integration structure which has to be defined. The \u0026ldquo;kinds\u0026rdquo; of a plugin is defined by the data required by the system. One data type, one plugin. Data Collection and Integration: While the module itself will not collect metrics directly, it must integrate seamlessly with external interfaces and tools that provide these metrics. The system must normalize data from various sources to a common schema suitable for analysis and reporting. The exposed metrics should be in opentelemetry format. Metric Enhancement: The module should have the capability to enhance the quality of metrics by combining data from multiple sources if reasonable. For example, in order to estimate carbon emissions energy, it resource and energy data needs to be caluclated. Scalability and Deployment: The system should support deployment in both single and multiple module configurations to facilitate varying levels of throughput. Ensure that the system can scale horizontally to manage increased load by adding more instances as required. Data Privacy and Security: Implement standard security measures to protect data integrity and confidentiality during the data collection and integration processes. Compliance with relevant data protection regulations must be ensured. 1.3.2. Non-Functional Requirements: # Performance: The system must process data efficiently, ensuring minimal latency in metric availability. Performance benchmarks should be established, particularly for data processing speeds and response times \u0026lt;100 milliseconds and in bulk \u0026lt;5 second. Reliability: The system must be robust, with capabilities to handle failures gracefully and ensure continuous operation. In the event that a module fails any modules that depend on it will either stop execution or publish parts of the requested data if available for later analysis. The user should have an interface to be aware of any failures happening. Upcon recovery modules should automatically restart, seaminglessly integrating already collected data if present with new data. Usability: The interface for managing plugins and configurations must be user-friendly, catering to technical users. Logs generated through using the system can be either send to the terminal or written in a file for further analysis. The system provides documentation on system setup, configuration, and management. Maintainability: The code base should be documented on a separate website and structured in such a way that easy maintenance and future upgrades are possible. The code follows common standards in terms of lining, inline comments and unit, integration and other testing if appropiate. In this way, it adheres to coding standards that promote code readability and reusability. Interoperability: The module should be compatible with existing and commonly used cloud native tools and platforms. Support for open standards and protocols to ensure seamless integration with a variety of data sources and tools. Open Source Development: The project is developed as open source project from the start. This includes a public repository, documentation, feature management, development and community structures (if required). 2. System Architecture # 2.1. Context # Carbonaut fits in a cloud native system.\nsequenceDiagram Alice-\u003e\u003eJohn: Hello John, how are you? John--\u003e\u003eAlice: Great! Alice-)John: See you later! 2.2. Plugins # 2.3. Internal Components / Building Blocks # 2.4. Deployment # 3. Data Dictionary # 4. Software Domain Design # 4.1. Software Application Domain Chart # 4.2. Software Application Domain # 4.2.1. Domain X # 4.2.1.1. Component Y of Domain X # 4.2.1.1. Task Z of Component Y1 of Domain X # 5. Data Design # Since the module does not store the data itself but rather exposes it, no additional database is required.\nscalability and performance\nsecurity considerations related to data\n5.1. Persistent/Static Data # 5.1.1. Dataset # 5.1.1. Static Data # 5.1.1. Persisted data # There is none persistent data. There may be data stored at runtime based on failures of plugins within the module which can force another plugin to \u0026ldquo;hold on the data\u0026rdquo; until the other plugin was restarted, the application shut down or no memory is left.\n5.2. Transient/Dynamic Data # This is the main part of the application.\n5.3. External Interface Data # 5.4. Transformation of Data # 6. User Interface # 6.1. User Interface Design Overview # 6.2. User Interface Navigation Flow # 6.3. Use Cases / User Function Description # 7. External Interfaces # 7.1. Interface X # 8. Comments # 9. References # 10. Glossary # "},{"id":4,"href":"/docs/reference/contributing/","title":"Contributing","section":"Reference","content":" Carbonaut Contributing # The Carbonaut project is a POC project and therefore no community structures are in place. If you find this project interesting enough to contribute, please open up an issue on the repository or directly a PR to discuss your idea. Any contributions are very welcome!\nDevelopment Workflow # Fork the repository and work on your fork. It\u0026rsquo;s recommended to create a feature branch on your fork and open pull requests from feature branches to Carbonaut\u0026rsquo;s main branch. If you have questions about forks, branches etc. take a look at GitHub\u0026rsquo;s documentation. If you forked the repository, install all dependencies, Go, pre-commit and then run make install to install other go nbased tools (see Makefile). If you intend to make changes to the manual testing scenario, refer to this guide. After that you can run make verify to check if everything is setup for local development. Ways of communication # GitHub issues and pull requests on the Carbonaut repository (no forks!) Additional Comments by area of contribution # Improve internal code: improvments are welcome! There are several TODO: XYZ annotations in the code that highlight some areas of improvements. Increasing test coverage and quality: improvements are welcome! The test coverage is not great. Test coverage is uploaded as artifact with each push to the main branch (see actions). You can also run test coverage of the Go code by executing make test-coverage. Adding Provider Plugins: make sure to test it both mocked and as E2E test. Proposing changing data schema or API: sure, make your case. The datamodels are minimal and not complete, changes are welcome. Improvements to this document are welcome!\n"},{"id":5,"href":"/docs/concepts/plugins/","title":"Plugins","section":"Concepts","content":" Carbonaut Plugins # TBD\ndocumentation not yet added "},{"id":6,"href":"/docs/concepts/advanced/","title":"Advanced","section":"Concepts","content":" Carbonaut Advanced Concepts # Internal State # TBD\ndocumentation not yet added "},{"id":7,"href":"/docs/","title":"Docs","section":"Introduction","content":" Carbonaut Docs # Documentation can be navigated by the sidebar.\nGet Home "},{"id":8,"href":"/docs/plugins/dyn-environment/energy-map/","title":"Energy Map","section":"Dynamic Environment","content":" Carbonaut Energy Map Plugin # TBD\ndocumentation not yet added "},{"id":9,"href":"/docs/plugins/dyn-resource/scaphandre/","title":"Scaphandre","section":"Dynamic Resource","content":" Carbonaut Scpahandre Plugin # TBD\ndocumentation not yet added "},{"id":10,"href":"/docs/plugins/static-resource/equinix/","title":"Equinix","section":"Static Resource","content":" Carbonaut Equinix Plugin # TBD\ndocumentation not yet added "},{"id":11,"href":"/docs/reference/schema/","title":"Schema","section":"Reference","content":" provider # import \u0026#34;carbonaut.dev/pkg/provider\u0026#34; Index # type Config type Data type EnvConfig type Res type ResConfig type Topology type Config # type Config struct { Resources ResConfig `json:\u0026#34;resources\u0026#34; yaml:\u0026#34;resources\u0026#34;` Environment *EnvConfig `json:\u0026#34;environment\u0026#34; yaml:\u0026#34;environment\u0026#34;` } type Data # type Data map[account.Name]account.Data type EnvConfig # type EnvConfig struct { DynamicEnvConfig *dynenv.Config `json:\u0026#34;dynamic_environment\u0026#34; yaml:\u0026#34;dynamic_environment\u0026#34;` } type Res # type Res struct { StaticResConfig *staticres.Config `json:\u0026#34;static_resource\u0026#34; yaml:\u0026#34;static_resource\u0026#34;` DynamicResConfig *dynres.Config `json:\u0026#34;dynamic_resource\u0026#34; yaml:\u0026#34;dynamic_resource\u0026#34;` } type ResConfig # type ResConfig map[account.Name]Res type Topology # internal state\ntype Topology struct { Accounts map[account.ID]*account.Topology `json:\u0026#34;accounts\u0026#34; yaml:\u0026#34;accounts\u0026#34;` AccountsIDCounter *int32 `json:\u0026#34;-\u0026#34;` } account # import \u0026#34;carbonaut.dev/pkg/provider/account\u0026#34; Index # type Data type ID type Name type Projects type Topology type Data # type Data map[project.Name]project.Data type ID # internal ID which get\u0026rsquo;s counted up\ntype ID int32 var NotFoundID ID = -1 type Name # defines the name of the account e.g. equinix\ntype Name string type Projects # type Projects map[project.ID]*project.Topology type Topology # internal state\ntype Topology struct { Name *Name `json:\u0026#34;name\u0026#34;` Projects Projects `json:\u0026#34;projects\u0026#34;` CreatedAt time.Time `json:\u0026#34;created_at\u0026#34;` ProjectIDCounter *int32 `json:\u0026#34;-\u0026#34;` Config *staticres.Config `json:\u0026#34;-\u0026#34;` } environment # import \u0026#34;carbonaut.dev/pkg/provider/environment\u0026#34; Index # type DynamicEnvData type DynamicEnvData # type DynamicEnvData struct { SolarPercentage float64 `json:\u0026#34;solar_percentage\u0026#34; yaml:\u0026#34;solar_percentage\u0026#34;` WindPercentage float64 `json:\u0026#34;wind_percentage\u0026#34; yaml:\u0026#34;wind_percentage\u0026#34;` HydroPercentage float64 `json:\u0026#34;hydro_percentage\u0026#34; yaml:\u0026#34;hydro_percentage\u0026#34;` NuclearPercentage float64 `json:\u0026#34;nuclear_percentage\u0026#34; yaml:\u0026#34;nuclear_percentage\u0026#34;` GeothermalPercentage float64 `json:\u0026#34;geothermal_percentage\u0026#34; yaml:\u0026#34;geothermal_percentage\u0026#34;` GasPercentage float64 `json:\u0026#34;gas_percentage\u0026#34; yaml:\u0026#34;gas_percentage\u0026#34;` OilPercentage float64 `json:\u0026#34;oil_percentage\u0026#34; yaml:\u0026#34;oil_percentage\u0026#34;` BiomassPercentage float64 `json:\u0026#34;biomass_percentage\u0026#34; yaml:\u0026#34;biomass_percentage\u0026#34;` CoalPercentage float64 `json:\u0026#34;coal_percentage\u0026#34; yaml:\u0026#34;coal_percentage\u0026#34;` OtherSourcesPercentage float64 `json:\u0026#34;other_sources_percentage\u0026#34; yaml:\u0026#34;other_sources_percentage\u0026#34;` FossilFuelsPercentage float64 `json:\u0026#34;fossil_fuels_percentage\u0026#34; yaml:\u0026#34;fossil_fuels_percentage\u0026#34;` RenewablePercentage float64 `json:\u0026#34;renewable_percentage\u0026#34; yaml:\u0026#34;renewable_percentage\u0026#34;` } plugin # import \u0026#34;carbonaut.dev/pkg/provider/plugin\u0026#34; Index # type Kind type Kind # type Kind string project # import \u0026#34;carbonaut.dev/pkg/provider/account/project\u0026#34; Index # type Data type ID type Name type Resources type Topology type Data # type Data map[resource.Name]*resource.Data type ID # internal ID which get\u0026rsquo;s counted up\ntype ID int32 var NotFoundID ID = -1 type Name # defines the name of the project e.g. equinix-project-a\ntype Name string type Resources # type Resources map[resource.ID]*resource.Topology type Topology # internal state\ntype Topology struct { Name *Name `json:\u0026#34;name\u0026#34;` Resources Resources `json:\u0026#34;resources\u0026#34;` CreatedAt time.Time `json:\u0026#34;created_at\u0026#34;` ResourceIDCounter *int32 `json:\u0026#34;-\u0026#34;` } dynenv # import \u0026#34;carbonaut.dev/pkg/provider/types/dynenv\u0026#34; Index # type Config type Provider type Config # type Config struct { Plugin *plugin.Kind `json:\u0026#34;plugin\u0026#34; yaml:\u0026#34;plugin\u0026#34;` AccessKeyEnv *string `json:\u0026#34;access_key_env\u0026#34; yaml:\u0026#34;access_key_env\u0026#34;` } type Provider # type Provider interface { GetName() *plugin.Kind GetDynamicEnvironmentData(*resource.Location) (*environment.DynamicEnvData, error) } dynres # import \u0026#34;carbonaut.dev/pkg/provider/types/dynres\u0026#34; Index # type Config type Provider type Config # type Config struct { Plugin plugin.Kind `json:\u0026#34;plugin\u0026#34; yaml:\u0026#34;plugin\u0026#34;` // Endpoint that is accessed to collec the data. // The IPv4 address will be collected from the static data thats looked up. Endpoint string `json:\u0026#34;endpoint\u0026#34; yaml:\u0026#34;endpoint\u0026#34;` // Client certificate file Cert string `json:\u0026#34;cert\u0026#34; yaml:\u0026#34;cert\u0026#34;` // Client certificate\u0026#39;s key file Key string `json:\u0026#34;key\u0026#34; yaml:\u0026#34;key\u0026#34;` // Accept any certificate during TLS handshake. Insecure, use only for testing AcceptInvalidCert bool `json:\u0026#34;accept_invalid_cert\u0026#34; yaml:\u0026#34;accept_invalid_cert\u0026#34;` } type Provider # type Provider interface { GetName() *plugin.Kind GetDynamicResourceData(*resource.StaticResData) (*resource.DynamicResData, error) } staticres # import \u0026#34;carbonaut.dev/pkg/provider/types/staticres\u0026#34; Index # type Config type Provider type Config # type Config struct { Plugin *plugin.Kind `json:\u0026#34;plugin\u0026#34; yaml:\u0026#34;plugin\u0026#34;` AccessKeyEnv *string `json:\u0026#34;access_key_env\u0026#34; yaml:\u0026#34;access_key_env\u0026#34;` } type Provider # type Provider interface { GetName() *plugin.Kind GetStaticResourceData(*project.Name, *resource.Name) (*resource.StaticResData, error) DiscoverStaticResourceIdentifiers(*project.Name) ([]*resource.Name, error) DiscoverProjectIdentifiers() ([]*project.Name, error) } resource # import \u0026#34;carbonaut.dev/pkg/provider/account/project/resource\u0026#34; Index # type CPU type DRIVE type Data type DynamicData type DynamicResData type GPU type ID type Location type NIC type Name type OS type StaticData type StaticResData type Topology type CPU # type CPU struct { Count int `json:\u0026#34;count\u0026#34; yaml:\u0026#34;count\u0026#34; default:\u0026#34;1\u0026#34;` Type string `json:\u0026#34;type\u0026#34; yaml:\u0026#34;type\u0026#34; default:\u0026#34;Intel Xeon E-2278G 8-Core Processor @ 3.40GHz\u0026#34;` Cores string `json:\u0026#34;cores\u0026#34; yaml:\u0026#34;cores\u0026#34; default:\u0026#34;8\u0026#34;` Threads string `json:\u0026#34;threads\u0026#34; yaml:\u0026#34;threads\u0026#34; default:\u0026#34;16\u0026#34;` Speed string `json:\u0026#34;speed\u0026#34; yaml:\u0026#34;speed\u0026#34; default:\u0026#34;3.40GHz\u0026#34;` Arch string `json:\u0026#34;arch\u0026#34; yaml:\u0026#34;arch\u0026#34; default:\u0026#34;x86\u0026#34;` Model string `json:\u0026#34;model\u0026#34; yaml:\u0026#34;model\u0026#34; default:\u0026#34;E-2278G\u0026#34;` Manufacturer string `json:\u0026#34;manufacturer\u0026#34; yaml:\u0026#34;manufacturer\u0026#34; default:\u0026#34;Intel\u0026#34;` Name string `json:\u0026#34;name\u0026#34; yaml:\u0026#34;name\u0026#34; default:\u0026#34;Intel Xeon E-2278G Processor\u0026#34;` } type DRIVE # type DRIVE struct { Count int `json:\u0026#34;count\u0026#34; yaml:\u0026#34;count\u0026#34; default:\u0026#34;2\u0026#34;` Type string `json:\u0026#34;type\u0026#34; yaml:\u0026#34;type\u0026#34; default:\u0026#34;SSD\u0026#34;` Size string `json:\u0026#34;size\u0026#34; yaml:\u0026#34;type\u0026#34; default:\u0026#34;480GB\u0026#34;` } type Data # type Data struct { DynamicData *DynamicData `json:\u0026#34;dynamic_data\u0026#34; yaml:\u0026#34;dynamic_data\u0026#34;` StaticData *StaticResData `json:\u0026#34;static_data\u0026#34; yaml:\u0026#34;static_data\u0026#34;` } type DynamicData # type DynamicData struct { ResData *DynamicResData `json:\u0026#34;res_data\u0026#34; yaml:\u0026#34;res_data\u0026#34;` EnvData *environment.DynamicEnvData `json:\u0026#34;env_data\u0026#34; yaml:\u0026#34;env_data\u0026#34;` } type DynamicResData # energy and utilization data\ntype DynamicResData struct { CPUFrequency float64 `json:\u0026#34;cpu_frequency\u0026#34; yaml:\u0026#34;cpu_frequency\u0026#34;` EnergyHostMicrojoules int `json:\u0026#34;energy_host_mirojoules\u0026#34; yaml:\u0026#34;energy_host_mirojoules\u0026#34;` CPULoadPercentage float64 `json:\u0026#34;cpu_load_percentage\u0026#34; yaml:\u0026#34;cpu_load_percentage\u0026#34;` } type GPU # type GPU struct { Count int `json:\u0026#34;count\u0026#34; yaml:\u0026#34;count\u0026#34; default:\u0026#34;1\u0026#34;` Type string `json:\u0026#34;type\u0026#34; yaml:\u0026#34;type\u0026#34; default:\u0026#34;Intel HD Graphics P630\u0026#34;` } type ID # internal ID which get\u0026rsquo;s counted up\ntype ID int32 var NotFoundID ID = -1 type Location # type Location struct { City string `json:\u0026#34;city\u0026#34; yaml:\u0026#34;city\u0026#34; default:\u0026#34;Frankfurt\u0026#34;` Country string `json:\u0026#34;country\u0026#34; yaml:\u0026#34;country\u0026#34; default:\u0026#34;DE\u0026#34;` Address string `json:\u0026#34;address\u0026#34; yaml:\u0026#34;address\u0026#34; default:\u0026#34;Kruppstrasse 121-127\u0026#34;` ZipCode string `json:\u0026#34;zip_code\u0026#34; yaml:\u0026#34;zip_code\u0026#34; default:\u0026#34;60388\u0026#34;` Code string `json:\u0026#34;code\u0026#34; yaml:\u0026#34;code\u0026#34; default:\u0026#34;fr\u0026#34;` } type NIC # type NIC struct { Count int `json:\u0026#34;count\u0026#34; yaml:\u0026#34;count\u0026#34; default:\u0026#34;1\u0026#34;` Type string `json:\u0026#34;type\u0026#34; yaml:\u0026#34;type\u0026#34; default:\u0026#34;10Gbps\u0026#34;` } type Name # defines the name of a resource which was found in an account e.g. equinix-server-b\ntype Name string type OS # type OS struct { Version string `json:\u0026#34;version\u0026#34; yaml:\u0026#34;version\u0026#34; default:\u0026#34;12\u0026#34;` Distro string `json:\u0026#34;distro\u0026#34; yaml:\u0026#34;distro\u0026#34; default:\u0026#34;debian\u0026#34;` Name string `json:\u0026#34;name\u0026#34; yaml:\u0026#34;name\u0026#34; default:\u0026#34;Debian 12\u0026#34;` } type StaticData # type StaticData struct { ResData *StaticResData `json:\u0026#34;res_data\u0026#34; yaml:\u0026#34;res_data\u0026#34;` } type StaticResData # Data represents computer hardware data.\ntype StaticResData struct { ID string `json:\u0026#34;id\u0026#34; yaml:\u0026#34;id\u0026#34; default:\u0026#34;0131acc3-82d8-488b-a8e2-c4a00e897145\u0026#34;` User string `json:\u0026#34;user\u0026#34; yaml:\u0026#34;user\u0026#34; default:\u0026#34;root\u0026#34;` OS *OS `json:\u0026#34;os\u0026#34; yaml:\u0026#34;os\u0026#34;` IPv4 string `json:\u0026#34;ipv4\u0026#34; yaml:\u0026#34;ipv4\u0026#34; default:\u0026#34;145.40.93.80\u0026#34;` CPUs []*CPU `json:\u0026#34;cpus\u0026#34; yaml:\u0026#34;cpus\u0026#34;` GPUs []*GPU `json:\u0026#34;gpus\u0026#34; yaml:\u0026#34;gpus\u0026#34;` NICs []*NIC `json:\u0026#34;nics\u0026#34; yaml:\u0026#34;nics\u0026#34;` Drives []*DRIVE `json:\u0026#34;drives\u0026#34; yaml:\u0026#34;drives\u0026#34;` MemoryGB string `json:\u0026#34;memory_gb\u0026#34; yaml:\u0026#34;memory_gb\u0026#34; default:\u0026#34;32GB\u0026#34;` Location *Location `json:\u0026#34;location\u0026#34; yaml:\u0026#34;location\u0026#34;` } type Topology # internal state\ntype Topology struct { Name *Name `json:\u0026#34;name\u0026#34;` StaticData *StaticResData `json:\u0026#34;static_data\u0026#34;` CreatedAt time.Time `json:\u0026#34;created_at\u0026#34;` Plugin *plugin.Kind `json:\u0026#34;plugin\u0026#34;` } Generated by gomarkdoc\n"}]